# GMP 及该模型好处

Go协程调度模型包含三个关键实体：machine(简称M)、processor(简称P)、Goroutine(简称G)。



## G(Goroutine)

即Go协程，每个go关键字都会创建一个协程。

使用struct runtime.g，包含当前的Goroutine状态、堆栈、上下文。

### 状态

Goroutine一共有以下几种状态，但是最常用的是前三种：

- 空闲中(_Gidle): 表示G刚刚新建, 仍未初始化

- 待运行(_Grunnable): 表示G在运行队列中, 等待M取出并运行

- 运行中(_Grunning): 表示M正在运行这个G, 这时候M会拥有一个P

- 系统调用中(_Gsyscall): 表示M正在运行这个G发起的系统调用, 这时候M并不拥有P

- 等待中(_Gwaiting): 表示G在等待某些条件完成, 这时候G不在运行也不在运行队列中(可能在channel的等待队列中)

- 已中止(_Gdead): 表示G未被使用, 可能已执行完毕(并在freelist中等待下次复用)

- 栈复制中(_Gcopystack): 表示G正在获取一个新的栈空间并把原来的内容复制过去(用于防止GC扫描)



## M(machine)

工作线程，对应真正的内核线程。

M必须和P绑定才可以跑Goroutine。

它由操作系统调度，也会被系统调用阻塞。

有自己的线程栈，当运行Goroutine代码时，M.stack指向G.stack，M的PC寄存器指向Go提供的函数，然后去执行。

### 状态

M并没有像G和P一样的状态标记, 但可以认为一个M有以下的状态:

- 自旋中(spinning): M正在从运行队列获取G, 这时候M会拥有一个P

- 执行go代码中: M正在执行go代码, 这时候M会拥有一个P

- 执行原生代码或陷入系统调用中: M正在执行原生代码或者阻塞的syscall, 这时M并不拥有P

- 休眠中: M发现无待运行的G时会进入休眠, 并添加到空闲M链表中, 这时M并不拥有P

是否需要唤醒或者创建新的M取决于当前自旋中的M的数量。

## P(processor)

处理器(Go定义的一个概念，不是指CPU，可以理解为执行上下文)。

包含Go代码的必要资源，也有调度Goroutine的能力。

P决定了并行数量，其个数在程序启动时决定，默认等于CPU的核心数量，可更改。

### 状态

- 空闲中(_Pidle): 当M发现无待运行的G时会进入休眠, 这时M拥有的P会变为空闲并加到空闲P链表中

- 运行中(_Prunning): 当M拥有了一个P后, 这个P的状态就会变为运行中, M运行G会使用这个P中的资源

- 系统调用中(_Psyscall): 当go调用原生代码, 原生代码又反过来调用go代码时, 使用的P会变为此状态

- GC停止中(_Pgcstop): 当gc停止了整个世界(STW)时, P会变为此状态

- 已中止(_Pdead): 当P的数量在运行时改变, 且数量减少时多余的P会变为此状态

## 本地运行队列

在go中有多个运行队列可以保存待运行(_Grunnable)的G, 它们分别是各个P中的本地运行队列和全局运行队列.

入队待运行的G时会优先加到当前P的本地运行队列, M获取待运行的G时也会优先从拥有的P的本地运行队列获取,

本地运行队列入队和出队不需要使用线程锁.

本地运行队列有数量限制, 当数量达到256个时会入队到全局运行队列.

本地运行队列的数据结构是环形队列, 由一个256长度的数组和两个序号(head, tail)组成.

当M从P的本地运行队列获取G时, 如果发现本地队列为空会尝试从其他P盗取一半的G过来,这个机制叫做Work Stealing

## 全局运行队列

全局运行队列保存在全局变量sched中, 全局运行队列入队和出队需要使用线程锁.

全局运行队列的数据结构是链表, 由两个指针(head, tail)组成.



## 空闲M链表

当M发现无待运行的G时会进入休眠, 并添加到空闲M链表中, 空闲M链表保存在全局变量sched.

进入休眠的M会等待一个信号量(m.park), 唤醒休眠的M会使用这个信号量.

go需要保证有足够的M可以运行G, 是通过这样的机制实现的:

入队待运行的G后, 如果当前无自旋的M但是有空闲的P, 就唤醒或者新建一个M

当M离开自旋状态并准备运行出队的G时, 如果当前无自旋的M但是有空闲的P, 就唤醒或者新建一个M

当M离开自旋状态并准备休眠时, 会在离开自旋状态后再次检查所有运行队列, 如果有待运行的G则重新进入自旋状态

因为"入队待运行的G"和"M离开自旋状态"会同时进行, go会使用这样的检查顺序:

入队待运行的G => 内存屏障 => 检查当前自旋的M数量 => 唤醒或者新建一个M

减少当前自旋的M数量 => 内存屏障 => 检查所有运行队列是否有待运行的G => 休眠

这样可以保证不会出现待运行的G入队了, 也有空闲的资源P, 但无M去执行的情况.



## 空闲P链表

当P的本地运行队列中的所有G都运行完毕, 又不能从其他地方拿到G时,

拥有P的M会释放P并进入休眠状态, 释放的P会变为空闲状态并加到空闲P链表中, 空闲P链表保存在全局变量sched

下次待运行的G入队时如果发现有空闲的P, 但是又没有自旋中的M时会唤醒或者新建一个M, M会拥有这个P, P会重新变为运行中的状态.





## GMP模型相对于GM模型的优点

### 全局互斥锁和集中状态存储问题

GM模型问题：Goroutine创建、结束、重新调度都要上锁。

GMP模型改善：G被分成全局队列和P的本地队列，可以显著改善锁的竞争激烈问题。

### Goroutine传递问题

GM模型问题：M与M之间互相传递可运行的Goroutine，缓存严重失效，引入大量的开销和延迟。

GMP模型改善：G创建时就在P的本地队列，可有效避免传递问题，同时有更好的数据局部性，系统调用返回时M还会优先找之前的P。

### 线程内存缓存问题

GM模型问题：每个线程都有自己的mcache，但实际上只有Goroutine运行时才需要，导致大量的内存占用并影响数据局部性。

GMP模型改善：mcache只存在于P中，P的数量会小于或远小于M的数量，节省内存且有更好的数据局部性。

### 线程频繁阻塞/解除阻塞问题

GM模型问题：在系统调用的情况下，工作线程经常被阻塞和解除阻塞，增加了很多上下文切换的开销。

GMP模型改善：通过引入自旋，保证任何时候都有处于等待状态的自旋M，避免在等待可用P和G时频繁的阻塞和解除阻塞。