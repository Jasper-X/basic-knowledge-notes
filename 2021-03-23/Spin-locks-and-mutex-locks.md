# 自旋锁与互斥锁的使用场景

### 原理

互斥锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，该线程挂起或睡眠。

自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放。

## 使用场景

互斥锁适用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑

- 临界区有IO操作
- 临界区代码复杂或者循环量大
- 临界区竞争非常激烈
- 单核处理器

自旋锁适用于临界区持锁时间非常短且CPU资源不紧张的情况下。

互斥锁的起始开销高于自旋锁，且有上下文切换，不过倒属于一劳永逸的方案，临界区的持锁时间长短不会对互斥锁的开销造成影响。

自旋锁是死循环检测，起始开销比互斥锁小，且没有上下文切换，但随着持锁时间增加，其开销会线性增加。

