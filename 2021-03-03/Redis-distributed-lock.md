# Redis 如何实现分布式锁？

分布式锁一般需要满足以下几个要求：

1. 同一时刻只能有一个Client获取到锁；
2. 锁是可重入的；
3. 不会发生死锁；
4. 具备阻塞锁特性，及时能从阻塞状态唤醒；
5. 高性能和高可用。



**基于Redis实现：**

使用set key value PX ms NX 命令，PX过期时间，NX保证只有一个Client获取到锁。

使用lua脚本保证获取锁的Client、对比释放锁的Client是否是所有者、释放锁这三个步骤是一个原子操作。

释放锁的lua脚本：

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

方案问题：

1. 通过过期时间避免死锁，需要给定一个合理过期时间，否则时间短了会造成锁的提前释放，导致资源的非法访问；时间长了当Client异常未释放锁时，造成其他Client的长时间等待；(这里可以其实可以做一个watch，防止提前释放。时间超出最高阈值时终止其操作，然后释放锁)
2. redis主从异步复制机制可能会丢失数据。比如：Client A获取到锁，锁的数据还未同步到Slave时Master挂了，Slave转为Master，此时Client B也可以获取到锁，造成资源的非法访问。(获取锁的时候顺序写bak_log，从切主时，检查锁资源，并尝试恢复)（可以采用简单的方法，读完主节点读从节点，如果都成功则代表成功的锁）



**基于ZooKeeper实现：**

加锁流程：在/resource_name节点下创建临时有序节点，Client获取锁时，获取自己创建的节点和resource_name目录下的最小节点，判断是否是同一个节点，如果是，代表获取到了锁，如果不是，锁等待。

zab 一致性协议保证了锁数据的安全性，不会因为数据丢失造成多个锁持有者；心跳保活机制解决死锁问题，防止由于进程挂掉或者僵死导致的锁长时间被无效占用。具备阻塞锁特性，并通过 watch 机制能够及时从阻塞状态被唤醒

解锁流程：删除当前Client创建的节点。

zookeeper不能注册

方案问题：

1. 通过心跳机制解决死锁会造成锁不安全，比如：获取到锁的Client A异常(僵死、网络故障)，导致zookeeper长时间收不到保活心跳，服务端认为其断开连接并主动释放锁，此时Client B获取到锁，Client A恢复，导致资源的非法访问；

**避免羊群效应**：正确的流程，在第二步不对所有子节点的变更进行watch，而是watch上一个节点：

1、客户端调用create()方法创建名为"_locknode_/lock-"的节点，节点类型EPHEMERAL_SEQUENTIAL

2、客户端调用getChildren( )获取已经创建的节点，不注册任何的watch

3、如果发现自己在步骤1创建的节点序号最小，说明获取到了锁

4、如果在步骤3中发现自己不是节点中最小的，说明自己还没有获取到锁，此时需要找到比自己小的节点，然后调用exist( )方法，同时注册事件监听

5、如果exists( ) 返回false，跳转到步骤2，否则，收到节点被移除的通知后，进入步骤2

​                           